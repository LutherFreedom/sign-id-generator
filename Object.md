# 对象

## 对象的创建
- 语言层面上： new关键字
- 虚拟机：new指令-> 检查指令参数能否在常量池中定位到一个类的符号引用->检查这个类的符号引用是否被加载、解析和初始化过（没有需要执行类记载）->为新生对象分配新内存（对象的大小在类加载完成后可确认）->设置对象头信息->执行<init>指令
<!-- more -->
## 对象的构成
- 对象头（Header）
- 实例数据（Instance Data）
- 对齐填充（Pending）

### 对象头
> 分为两部分：  
- 1）用于存储对象自身运行的数据，如hashCode，GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳。官方成为MarkWord， MarkWord是非固定的数据结构，以便能够存储更多的数据。 
- 2) 类型指针，对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
### 实例数据
- 对象真正存储的有效信息（代码中定义的各种类型字段内容）
- 存储顺序受虚拟机分配策略参数和字段在Java源码上定义的顺序影响。
- 分配策略：longs/doubles、ints、shorts/chars、bytes/booleans、oops， 相同宽度的字段总是分配到一起的。在满足这个条件下，父类定义的变量会在子类之前。如果CompactFields的值是true，子类较窄的变量可能会插入到父类的间隙中。
### 对齐填充
- 不是必然存在
- 占位符作用，使得对象大小是8bit的整数倍。（HotSpot VM的自动内存管理系统要求对象起始地址必须是8bit的整数倍）
- 当对象实例数据部分未对齐时，需要通过对齐填充来补全
## 对象的访问定位
>使用句柄和直接指针这两种方式访问对象
### 句柄访问
- Heap中会划分一部分内存来作为句柄池
- 引用（Reference）中存储的时对象的句柄地址
- 句柄包含对象实例数据的指针和对象类型数据的指针
> 优点：Reference存储的是稳定的句柄地址，对象被移动时只改变句柄中的实例数据指针就行了
### 直接指针访问
- 引用（Reference）中存储的是对象地址，对象实例数据中包含了对象类型数据的指针。
> 优点：速度更快，节省了一次指针定位时间开销。目前HotSpot使用第二种方式进行对象访问
