# 分布式发号器

## 为什么不用UUID
### UUID的优点（advantage）
- 保证ID的唯一性
### UUID的缺点（disadvantage）
- 无法满足业务系统需要的其他特性
- 使用完全的时间数据，性能较差
- UUID比较长、占用空间大，导致数据性能下降
- 不具备粗略的有序性，导致`B+`树索引过多的随机写操作
- 在写的时候不能产生有序的`append`操作，而进行`insert`操作，将读取整个`B+`树到内存，在插入记录后会将整个节点写回磁盘。

## 基于数据库的实现
### 数据库的优点（davantage）
- 基于数据库，在数据库层面进行自增，不需开发操作
### 数据库的缺点（disadvantage）
- 自增字段完全依赖数据库，在后期进行数据库移植、扩容、清洗数据、分库分表等操作时会带来麻烦

### 分库分表的解决方案
- 调整自增字段或者调整数据库`sequence`的步长来确保跨数据库的ID的唯一性
#### 方案
- 服务节点：8个
- 每个服务节点使用一个`sequence`功能产生ID，每个的`sequence`起始ID不同，但是step都是8.

#### 缺点
- 服务节点固定，步长也固定。如果增加服务节点，难以进行水平扩展
- 依赖数据库，对数据库造成压力
- 多个`sequence`疏散管理，增加维护成本

## 基于后缀数字的实现
- 在生成`ID`的后面添加数字后缀，以区分各服务节点。但同一批次的数据ID后缀应保证一致

## 分布式系统对发号器的基本需求
### 全局唯一性
- 某些情况下使用相对小范围的唯一性，例如用户具有唯一性，那么同一用户的订单的自增序列在用户范围内也是唯一， 但是会产生业务上的依赖。
- 使用时间的有序性，在时间的某个单元下采用自增序列，来达到全局唯一。
- 分布式系统保证全局唯一的一个悲观策略是使用锁或者分布式锁，但是这样会影响性能。
### 粗略有序
- UUID最大的问题是无序，但是做到完全有序很难，因为要使用到锁或者分布式锁，这样效率就会很低下
- 粗略有序，保证粗略有序即可，主流方案：秒级有序、毫秒级有序
### 可反解
- 一个ID生成之后，本身要带有一定的信息，当线上排查时，我们要能够知道它什么时候产生的以及从哪里产生的
### 可制造
- 考虑到系统出现问题后，我们需要手工处理。或者数据被污染后，我们需要清洗数据。在涉及到这些方面时，数据的自增字段已经被后面的业务覆盖了，这样我们不能恢复到数据出问题的时间节点上，所以需要一个可复制、可恢复、可制造的ID
### 高性能
- 发号器的性能很重要，因为几乎每个系统都会使用到，也就是说发号器的生成对性能要求很高。
- ID生成取决于网络I/O和CPU的性能，一半网络I/O的TPS能达到10000/s
### 高可用
- 使用集群可以解决这个问题，当一个服务挂掉之后，请求必须能够转发到其他的机器上，所以重试机制是必不可少的
- 当远程服务宕机之后，我们需要本地的容错机制
### 可伸缩
- 因为业务在不断的增长， 所以业务的绝对容量不是衡量系统性能的唯一标准。
- 对系统的设计不但要考虑能承受的绝对容量，还要考虑业务量的增长速度。
- 系统的水平伸缩能否满足业务的增长速度，是衡量系统性能的另一个重要标准

## 设计要点
### 发布模式
- 嵌入发布模式：只使用与java客户端，提供本地Jar。需提前配置本地的机器ID，不能依赖中心服务器
- 中心服务器发布模式：只适用Java客户端，程序像调用本地API一样调用，但是依赖于中心的ID产生服务器
- REST发布模式：RestfulApi，可提供给其他语言使用

### ID类型
- 最大峰值型：能够承受更大的峰值压力，但是粒度较大  
|字段|版本|类型|生成方式|秒级时间|序列号|机器ID|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|位数|63|62|60-61|30-59|10-29|0-9|
- 最大粒度型：粒度细致，理论上能够承受理论峰值（1024），如果同个毫秒有更多请求产生时，必须等到下一个毫米再响应  
|字段|版本|类型|生成方式|毫秒级时间|序列号|机器ID|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|位数|63|62|60-61|20-59|10-19|0-9|

### 数据结构
- 机器ID：10位数字，2^10=1024,及支持1024个服务
- 序列号：
> 最大峰值型：20位，为百万级别  
> 最小了粒度型: 10位，每1毫秒最多产生1024个ID, 理论上承受的峰值完全不如最大峰值方案
- 秒级时间/毫秒级时间
> 最大峰值型：30位，可用30多年  
> 最小粒度型：30位，可用30多年  
- 生成方式
> 2位，用来区分三种发布模式：嵌入发布模式、中心服务器发布模式、REST发布模式  
> 00: 嵌入发布模式  
> 01: 中心服务器发布模式  
> 02: REST发布模式  
> 03: 保留未用
- ID类型
> 1位  
> 0：最大峰值型  
> 1：最小力度性  
- 版本
> 1位  
> 0: 默认值
> 1: 表示扩展或者扩容中

### 并发
#### 中心服务器和REST发布方式
- ID生成的过程设计网络I/O、CPU操作。ID的生成基本上是内存到高速缓存的操作，没有磁盘I/O的操作，网络I/O是系统瓶颈
- ID产生的服务使用多线程的方式，对于ID生成过程中的竞争点time和sequence，使用多种解决方案  
> 使用`ReentrantLock`进行互斥， 默认实现方式
> 使用`Synchronized`进行互斥，这个方式性能逊色一些，通过传出JVM参数`-Dsigngenerator.sync.lock.impl.key=true`
> 使用原子变量进行互斥，性能高，传入JVM参数`-Dsigngenerator.atomic.impl.key=true`开启
### 机器ID分配
- 分为两个区段，`0-923`嵌入发布模式，`924-1023`中心服务器发布模式和Rest发布模式
- 机器ID的分配方式：
> 通过共享数据库的方式为发号器服务池中的每个节点生成唯一机器ID，适合服务池中节点比较多的情况  
> 通过配置发号器服务池中的每个节点IP的方式确定每个节点的机器ID，适合服务池中节点比较少的情况  
> 在Spring配置文件中直接配置每个节点的机器ID，适合测试时使用  

- 可以试着使用Zookeeper为基础的机器ID的生成器
### 时间同步
#### 时间变动对发号器的影响
- 调整时间是否影响ID的产生
> 未重启机器调慢时间，发号器抛出异常，拒绝产生ID。调整正常后产生ID，在调整时段内没有ID产生  
> 重启机器调慢时间，发号器产生重复ID，必须保证不会发生这种情况。调整正常后产生ID，在调整时段内没有ID产生  

- 闰年同步闰秒是否影响ID的产生
> 原子始终与电子时钟每四年误差一秒，需要手工同步。但由于是调快一秒，调整后不影响ID的产生

### 设计验证
- 根据不同信息分段构建ID，使ID具有全局唯一、可反解、可制造型等特性
- 使用秒级